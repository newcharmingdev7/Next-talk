import { Localized } from "fluent-react/compat";
import { RouteProps } from "found";
import React from "react";
import { graphql, GraphQLTaggedNode, RelayPaginationProp } from "react-relay";

import { QueueRoute_queue as QueueData } from "coral-admin/__generated__/QueueRoute_queue.graphql";
import { QueueRoute_settings as SettingsData } from "coral-admin/__generated__/QueueRoute_settings.graphql";
import { QueueRoutePaginationPendingQueryVariables } from "coral-admin/__generated__/QueueRoutePaginationPendingQuery.graphql";
import { IntersectionProvider } from "coral-framework/lib/intersection";
import { withPaginationContainer } from "coral-framework/lib/relay";

import EmptyMessage from "./EmptyMessage";
import LoadingQueue from "./LoadingQueue";
import Queue from "./Queue";

interface QueueRouteProps {
  queue: QueueData;
  settings: SettingsData;
  relay: RelayPaginationProp;
  emptyElement: React.ReactElement;
  storyID?: string;
}

// TODO: use generated types
const danglingLogic = (status: string) =>
  ["APPROVED", "REJECTED"].indexOf(status) >= 0;

export class QueueRoute extends React.Component<QueueRouteProps> {
  public static routeConfig: RouteProps;

  public state = {
    disableLoadMore: false,
  };

  public render() {
    const comments = this.props.queue.comments.edges.map(edge => edge.node);
    return (
      <IntersectionProvider>
        <Queue
          comments={comments}
          settings={this.props.settings}
          onLoadMore={this.loadMore}
          hasMore={this.props.relay.hasMore()}
          disableLoadMore={this.state.disableLoadMore}
          danglingLogic={danglingLogic}
          emptyElement={this.props.emptyElement}
          allStories={!Boolean(this.props.storyID)}
        />
      </IntersectionProvider>
    );
  }

  private loadMore = () => {
    if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {
      return;
    }
    this.setState({ disableLoadMore: true });
    this.props.relay.loadMore(
      10, // Fetch the next 10 feed items
      error => {
        this.setState({ disableLoadMore: false });
        if (error) {
          // tslint:disable-next-line:no-console
          console.error(error);
        }
      }
    );
  };
}

// TODO: (cvle) If this could be autogenerated..
type FragmentVariables = QueueRoutePaginationPendingQueryVariables;

const createQueueRoute = (
  queueQuery: GraphQLTaggedNode,
  paginationQuery: GraphQLTaggedNode,
  emptyElement: React.ReactElement
) => {
  const enhanced = (withPaginationContainer<
    QueueRouteProps,
    QueueRoutePaginationPendingQueryVariables,
    FragmentVariables
  >(
    {
      queue: graphql`
        fragment QueueRoute_queue on ModerationQueue
          @argumentDefinitions(
            count: { type: "Int!", defaultValue: 5 }
            cursor: { type: "Cursor" }
          ) {
          count
          comments(first: $count, after: $cursor)
            @connection(key: "Queue_comments") {
            edges {
              node {
                id
                ...ModerateCardContainer_comment
              }
            }
          }
        }
      `,
      settings: graphql`
        fragment QueueRoute_settings on Settings {
          ...ModerateCardContainer_settings
        }
      `,
    },
    {
      direction: "forward",
      getConnectionFromProps(props) {
        return props.queue && props.queue.comments;
      },
      // This is also the default implementation of `getFragmentVariables` if it isn't provided.
      getFragmentVariables(prevVars, totalCount) {
        return {
          ...prevVars,
          count: totalCount,
        };
      },
      getVariables(props, { count, cursor }, fragmentVariables) {
        return {
          ...fragmentVariables,
          count,
          cursor,
        };
      },
      query: paginationQuery,
    }
  )(QueueRoute) as any) as typeof QueueRoute;

  enhanced.routeConfig = {
    Component: enhanced,
    query: queueQuery,
    cacheConfig: { force: true },
    render: ({ Component, props, match }) => {
      const anyProps = props as any;
      if (Component && props) {
        const queue =
          anyProps.moderationQueues[Object.keys(anyProps.moderationQueues)[0]];
        return (
          <Component
            queue={queue}
            settings={anyProps.settings}
            emptyElement={emptyElement}
            storyID={match.params.storyID}
          />
        );
      }
      return <LoadingQueue />;
    },
  };

  return enhanced;
};

export const PendingQueueRoute = createQueueRoute(
  graphql`
    query QueueRoutePendingQuery($storyID: ID) {
      moderationQueues(storyID: $storyID) {
        pending {
          ...QueueRoute_queue
        }
      }
      settings {
        ...QueueRoute_settings
      }
    }
  `,
  graphql`
    # Pagination query to be fetched upon calling 'loadMore'.
    # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
    query QueueRoutePaginationPendingQuery(
      $storyID: ID
      $count: Int!
      $cursor: Cursor
    ) {
      moderationQueues(storyID: $storyID) {
        pending {
          ...QueueRoute_queue @arguments(count: $count, cursor: $cursor)
        }
      }
    }
  `,
  // tslint:disable-next-line:jsx-wrap-multiline
  <Localized id="moderate-emptyQueue-pending">
    <EmptyMessage>
      Nicely done! There are no more pending comments to moderate.
    </EmptyMessage>
  </Localized>
);

export const ReportedQueueRoute = createQueueRoute(
  graphql`
    query QueueRouteReportedQuery($storyID: ID) {
      moderationQueues(storyID: $storyID) {
        reported {
          ...QueueRoute_queue
        }
      }
      settings {
        ...QueueRoute_settings
      }
    }
  `,
  graphql`
    # Pagination query to be fetched upon calling 'loadMore'.
    # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
    query QueueRoutePaginationReportedQuery(
      $storyID: ID
      $count: Int!
      $cursor: Cursor
    ) {
      moderationQueues(storyID: $storyID) {
        reported {
          ...QueueRoute_queue @arguments(count: $count, cursor: $cursor)
        }
      }
    }
  `,
  // tslint:disable-next-line:jsx-wrap-multiline
  <Localized id="moderate-emptyQueue-reported">
    <EmptyMessage>
      Nicely done! There are no more reported comments to moderate.
    </EmptyMessage>
  </Localized>
);

export const UnmoderatedQueueRoute = createQueueRoute(
  graphql`
    query QueueRouteUnmoderatedQuery($storyID: ID) {
      moderationQueues(storyID: $storyID) {
        unmoderated {
          ...QueueRoute_queue
        }
      }
      settings {
        ...QueueRoute_settings
      }
    }
  `,
  graphql`
    # Pagination query to be fetched upon calling 'loadMore'.
    # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
    query QueueRoutePaginationUnmoderatedQuery(
      $storyID: ID
      $count: Int!
      $cursor: Cursor
    ) {
      moderationQueues(storyID: $storyID) {
        unmoderated {
          ...QueueRoute_queue @arguments(count: $count, cursor: $cursor)
        }
      }
    }
  `,
  // tslint:disable-next-line:jsx-wrap-multiline
  <Localized id="moderate-emptyQueue-unmoderated">
    <EmptyMessage>Nicely done! All comments have been moderated.</EmptyMessage>
  </Localized>
);
